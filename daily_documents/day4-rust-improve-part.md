# Rust 生命周期

## 生命周期的引入

Rust 引入生命周期的主要目的是为了解决**借用**引起相关的安全问题，确保所有引用都是有效的，避免出现[悬垂引用](#悬垂引用)和[数据竞争](#数据竞争)等内存安全问题。

### 悬垂引用

> **悬垂引用（Dangling Reference）** 是指指向已释放或无效内存的指针。

```rust
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

执行结果：

```bash
  --> src/main.rs:7:13
   |
6  |         let x = 5;
   |             - binding `x` declared here
7  |         r = &x;
   |             ^^ borrowed value does not live long enough
8  |     }
   |     - `x` dropped here while still borrowed
9  |
10 |     println!("r: {}", r);
   |                       - borrow later used here

For more information about this error, try `rustc --explain E0597`.
```

### 数据竞争

> **数据竞争（Data Race）** 是并发操作中的一种常见错误，它发生在多个线程或进程同同时访问同一块内存区域，并且至少有一个线程或进程是在写入数据，这些访问没有适当的同步措施来控制它们的执行顺序，从而导致程序的不可预测的现象。

数据竞争发生条件通常包括以下几点：

1. 多个线程或进程访问同一片共享内存。
2. 至少有一个线程或进程在写入该内存区域。
3. 对共享内存的访问没有通过互斥锁、信号量等同步机制来适当地同步。
4. 由于缺乏同步，线程或进程的执行顺序不是确定的，可能会导致不一致的状态。

数据竞争可能导致多种问题，包括**程序崩溃**、**数据损坏**、**不可重复**的结果等。


## 生命周期提供的解决方案

Rust 通过**借用检查（Borrow Checking）**、**生命周期参数（Lifetime Parameters）**、**生命周期省略规则（Lifetime Elision Rules）** 三种方式来构建其生命周期系统，来作为避免悬垂引用和数据竞争的解决方案。

### 借用检查

Rust 编译器在编译时会进行借用检查，确保引用总是有效的。

一言以蔽之：**确保依赖有效**。

```rust
/*0*/{
/*1*/    let r;                 // ---------+-- 'a
/*2*/                           //          |
/*3*/    {                      //          |
/*4*/        let x = 5;         // -+-- 'b  |
/*5*/        r = &x;            //  |       |
/*6*/    }                      // -+       |
/*7*/                           //          |
/*8*/    println!("r: {}", r);  //          |
/*9*/}                          // ---------+
```

- `r` 原本的生命周期`'a`为 1~9 行。
- 依赖 `x` 的生命周期`'b`为 4~5 行。

因此， `r` 的真实生命周期为 1~5 行，故第 8 行引用了无效的 `r`，因此报错。

### 生命周期参数

函数生命周期参数标注是一种语法，用于在函数的签名中执行引用参数的生命周期关系，这种标注帮助编译器进行借用检查，确保引用在函数的调用过程中始终有效。

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {}
```

- 和泛型一样，使用生命周期参数，需要先声明 `<'a>`
- `x`、`y` 和返回值至少活得和 `'a` 一样久

### 生命周期省略规则

生命周期省略规则，主要是为了减少开发者的负担，使得在一些常见情况下，编译器能够自行推导生命周期而无需显式标注。

三条生命周期省略规则如下：

1. 每个引用参数都会获得独自的生命周期。
2. 若只有一个输入生命周期（函数参数只有一个引用类型），那么该生命周期会被赋予所有输出生命周期。
3. 若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期。

通过两个例子来理解这三条规则：

**例1：**

```rust
fn first_world(s: &str) -> &str {}
```
编译器会首先应用第一条规则，为每个参数标注一个生命周期：

```rust
fn first_world<'a>(s: &'a str) -> &str {}
```
此时，编译器会应用第二条规则，因为该函数只有一个输入生命周期，因此该声明周期也会被赋予所有输出声明周期。
```rust
fn first_world<'a>(s: &'a str) -> &'a str {}
```
到这里，编译器为函数签名中的所有引用都自动添加了具体的生命周期，因此编译通过，且用户无需手动标注生命周期。

**例2：**

```rust
fn longest(x: &str, y: &str) -> &str {}
```
编译器会首先应用第一条规则，为每个参数标注一个生命周期：

```rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {}
```

之后编译器无法应用第二条规则，因为输入周期有两个。


## 生命周期的实践效果及评价





